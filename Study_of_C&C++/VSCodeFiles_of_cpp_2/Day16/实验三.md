# 任务一

## 组合类

### 源码
> button.hpp

```cpp
#pragma once
#include <iostream>
#include <string>

class Button {
public:
    Button(const std::string &label_);
    const std::string& get_label() const;
    void click();

private:
    std::string label;
};

Button::Button(const std::string &label_): label{label_} {
}

inline const std::string& Button::get_label() const {
    return label;
}

inline void Button::click() {
    std::cout << "Button '" << label << "' clicked\n";
}
```

> window.hpp

```cpp
#pragma once
#include <iostream>
#include <vector>
#include <algorithm>
#include "button.hpp"

// 窗口类
class Window{
public:
    Window(const std::string &title_);
    void display() const;
    void close();
    void add_button(const std::string &label);
    void click_button(const std::string &label);

private:
    bool has_button(const std::string &label) const;

private:
    std::string title;
    std::vector<Button> buttons;
};

Window::Window(const std::string &title_): title{title_} {
    buttons.push_back(Button("close"));
}

inline void Window::display() const {
    std::string s(40, '*');
    std::cout << s << std::endl;
    std::cout << "window : " << title << std::endl;
    int cnt = 0;
    for(const auto &button: buttons)
        std::cout << ++cnt << ". " << button.get_label() << std::endl;
    std::cout << s << std::endl;
}

inline void Window::close() {
    std::cout << "close window '" << title << "'" << std::endl;
    click_button("close");
}

inline bool Window::has_button(const std::string &label) const {
    for(const auto &button: buttons)
        if(button.get_label() == label)
            return true;
    return false;
}

inline void Window::add_button(const std::string &label) {
    if(has_button(label))
        std::cout << "button " << label << " already exists!\n";
    else
        buttons.push_back(Button(label));
}

inline void Window::click_button(const std::string &label) {
    for(auto &button:buttons)
        if(button.get_label() == label) {
            button.click();
            return;
        }
    std::cout << "no button: " << label << std::endl;
}
```

> task1.cpp

```cpp
#include "window.hpp"
#include <iostream>

void test(){
    Window w("Demo");
    w.add_button("add");
    w.add_button("remove");
    w.add_button("modify");
    w.add_button("add");
    w.display();
    w.close();
}

int main() {
    std::cout << "用组合类模拟简单GUI:\n";
    test();
}
```

### 结果

```
用组合类模拟简单GUI:
****************************************
window : Demo
1. close
2. add
3. remove
4. modify
****************************************
close window 'Demo'
Button 'close' clicked
```

### 回答

- Window 和 Button 是组合关系。Window 对象包含 `std::vector<Button>`，体现 has-a。
- 把 `has_button` 设为 public 的优点是外部可查询按钮是否存在；风险是泄露内部实现、提升耦合，调用者可能据此编写脆弱逻辑破坏不变式（先查再加的竞态或重复判断）。
- public 与 private 的判定应基于是否为对外有意义的能力、是否仅为内部细节、是否可能破坏对象状态与不变式，遵循最小接口原则。
- `const std::string&` 返回避免拷贝、性能更优，但受对象生命周期约束且不可修改；返回 `std::string` 有值语义、无需关心生命周期但产生一次拷贝（小字符串优化与返回值优化可降低成本）。
- `push_back(Button(label))` 先构造临时再移动/拷贝；`emplace_back(label)` 原位构造，避免临时对象，一般更高效，两者在此示例功能等价。

# 任务二

## 深复制：std::vector

### 源码
> task2.cpp

```cpp
#include <iostream>
#include <vector>

void test1();
void test2();
void output1(const std::vector<int> &v);
void output2(const std::vector<int> &v);
void output3(const std::vector<std::vector<int>>& v);

int main() {
    std::cout << "深复制验证1: 标准库vector<int>\n";
    test1();
    std::cout << "\n深复制验证2: 标准库vector<int>嵌套使用\n";
    test2();
}

void test1() {
    std::vector<int> v1(5, 42);
    const std::vector<int> v2(v1);
    std::cout << "**********拷贝构造后**********\n";
    std::cout << "v1: "; output1(v1);
    std::cout << "v2: "; output1(v2);
    v1.at(0) = -1;
    std::cout << "**********修改v1[0]后**********\n";
    std::cout << "v1: "; output1(v1);
    std::cout << "v2: "; output1(v2);
}

void test2() {
    std::vector<std::vector<int>> v1{{1, 2, 3}, {4, 5, 6, 7}};
    const std::vector<std::vector<int>> v2(v1);
    std::cout << "**********拷贝构造后**********\n";
    std::cout << "v1: "; output3(v1);
    std::cout << "v2: "; output3(v2);
    v1.at(0).push_back(-1);
    std::cout << "**********修改v1[0]后**********\n";
    std::cout << "v1: \n";  output3(v1);
    std::cout << "v2: \n";  output3(v2);
}

// 使用xx.at()+循环输出vector<int>数据项
void output1(const std::vector<int> &v) {
    if(v.size() == 0) {
        std::cout << '\n';
        return;
    }
    std::cout << v.at(0);
    for(auto i = 1; i < v.size(); ++i)
        std::cout << ", " << v.at(i);
    std::cout << '\n';
}

// 使用迭代器+循环输出vector<int>数据项
void output2(const std::vector<int> &v) {
    if(v.size() == 0) {
        std::cout << '\n';
        return;
    }
    auto it = v.begin();
    std::cout << *it;
    for(it = v.begin()+1; it != v.end(); ++it)
        std::cout << ", " << *it;
    std::cout << '\n';
}

// 使用auto for分行输出vector<vector<int>>数据项
void output3(const std::vector<std::vector<int>>& v) {
    if(v.size() == 0) {
        std::cout << '\n';
        return;
    }
    for(auto &i: v)
        output2(i);
}
```

### 结果

```
深复制验证1: 标准库vector<int>
**********拷贝构造后**********
v1: 42, 42, 42, 42, 42
v2: 42, 42, 42, 42, 42
**********修改v1[0]后**********
v1: -1, 42, 42, 42, 42
v2: 42, 42, 42, 42, 42

深复制验证2: 标准库vector<int>嵌套使用
**********拷贝构造后**********
v1: 1, 2, 3
4, 5, 6, 7
v2: 1, 2, 3
4, 5, 6, 7
**********修改v1[0]后**********
v1:
1, 2, 3, -1
4, 5, 6, 7
v2:
1, 2, 3
4, 5, 6, 7
```

### 回答

- `std::vector<int> v1(5, 42);` 构造 5 个值为 42 的元素；`const std::vector<int> v2(v1);` 拷贝构造一个副本，二者各含 5 个 42。
- 嵌套场景拷贝后：`v1.size()==2`、`v2.size()==2`、`v1[0].size()==3`。
- `at()` 与 `operator[]` 效果相同但安全性不同：`at()` 边界检查，越界抛异常/报错退出；`[]` 不检查，越界未定义行为。
- 执行 `v1.at(0).push_back(-1);` 后，`v1` 第一行输出包含 -1，`v2` 不变，体现深复制。以 `const &` 接收返回值可避免拷贝、节省内存，但不可修改且需保证被引用对象存续。
- 标准库 `vector` 的拷贝构造是深复制；`vector<T>::at()` 在非 const 容器返回 `T&`，在 const 容器返回 `const T&`，因此必须提供 const 与非 const 重载以匹配语义。

# 任务三

## 自定义简化 vectorInt

### 源码
> vectorInt.hpp

```cpp
#pragma once
#include <iostream>

// 动态int数组对象类
class vectorInt{
public:
    vectorInt();
    vectorInt(int n_);
    vectorInt(int n_, int value);
    vectorInt(const vectorInt &vi);
    ~vectorInt();
    
    int size() const;
    int& at(int index);
    const int& at(int index) const;
    vectorInt& assign(const vectorInt &vi);
    
    int* begin();
    int* end();
    const int* begin() const;
    const int* end() const;

private:
    int n;      // 当前数据项个数
    int *ptr;   // 数据区
};

vectorInt::vectorInt():n{0}, ptr{nullptr} {
}

vectorInt::vectorInt(int n_): n{n_}, ptr{new int[n]} {
}

vectorInt::vectorInt(int n_, int value): n{n_}, ptr{new int[n_]} {
    for(auto i = 0; i < n; ++i)
        ptr[i] = value;
}

vectorInt::vectorInt(const vectorInt &vi): n{vi.n}, ptr{new int[n]} {
    for(auto i = 0; i < n; ++i)
        ptr[i] = vi.ptr[i];
}

vectorInt::~vectorInt() {
    delete [] ptr;
}

int vectorInt::size() const {
    return n;
}

const int& vectorInt::at(int index) const {
    if(index < 0 || index >= n) {
        std::cerr << "IndexError: index out of range\n";
        std::exit(1);
    }
    return ptr[index];
}

int& vectorInt::at(int index) {
    if(index < 0 || index >= n) {
        std::cerr << "IndexError: index out of range\n";
        std::exit(1);
    }
    return ptr[index];
}

vectorInt& vectorInt::assign(const vectorInt &vi) {
    if(this == &vi)
        return *this;
    
    int *ptr_tmp;
    ptr_tmp = new int[vi.n];
    for(int i = 0; i < vi.n; ++i)
        ptr_tmp[i] = vi.ptr[i];
    
    delete[] ptr;
    n = vi.n;
    ptr = ptr_tmp;
    return *this;
}

int* vectorInt::begin() {
    return ptr;
}

int* vectorInt::end() {
    return ptr+n;
}

const int* vectorInt::begin() const {
    return ptr;
}

const int* vectorInt::end() const {
    return ptr+n;
}
```

> task3.cpp

```cpp
#include "vectorInt.hpp"
#include <iostream>

void test1();
void test2();
void output1(const vectorInt &vi);
void output2(const vectorInt &vi);

int main() {
    std::cout << "测试1: \n";
    test1();
    std::cout << "\n测试2: \n";
    test2();
}

void test1() {
    int n;
    std::cout << "Enter n: ";
    std::cin >> n;
    
    vectorInt x1(n);
    for(auto i = 0; i < n; ++i)
        x1.at(i) = (i+1)*10;
    
    std::cout << "x1: ";  output1(x1);
    
    vectorInt x2(n, 42);
    vectorInt x3(x2);
    x2.at(0) = -1;
    
    std::cout << "x2: ";  output1(x2);
    std::cout << "x3: ";  output1(x3);
}

void test2() {
    const vectorInt  x(5, 42);
    vectorInt y;
    y.assign(x);
    
    std::cout << "x: ";  output2(x);
    std::cout << "y: ";  output2(y);
}

// 使用xx.at()+循环输出vectorInt对象数据项
void output1(const vectorInt &vi) {
    if(vi.size() == 0) {
        std::cout << '\n';
        return;
    }
    std::cout << vi.at(0);
    for(auto i = 1; i < vi.size(); ++i)
        std::cout << ", " << vi.at(i);
    std::cout << '\n';
}

// 使用迭代器+循环输出vectorInt对象数据项
void output2(const vectorInt &vi) {
    if(vi.size() == 0) {
        std::cout << '\n';
        return;
    }
    auto it = vi.begin();
    std::cout << *it;
    for(it = vi.begin()+1; it != vi.end(); ++it)
        std::cout << ", " << *it;
    std::cout << '\n';
}
```

### 结果

```
测试1:
Enter n: 5
x1: 10, 20, 30, 40, 50
x2: -1, 42, 42, 42, 42
x3: 42, 42, 42, 42, 42

测试2:
x: 42, 42, 42, 42, 42
y: 42, 42, 42, 42, 42
```

### 回答

- assign 版本2未做自赋值检查：`this == &vi` 时会先 `delete[] ptr` 再读 `vi.ptr`，造成悬空访问；且不具备异常安全，若新分配/复制过程中抛出异常对象会处于不一致状态。
- `static_cast<const vectorInt*>(this)` 把 `this` 从 `vectorInt*` 转为 `const vectorInt*`，目的是复用 const 重载；随后 `const_cast<int&>` 去除 const，返回非常量引用，从而消除实现重复。
- `v1.begin()` 选择非常量重载，返回 `int*` 以支持写；`v2.begin()` 选择常量重载，返回 `const int*` 以只读遍历。非常量用于可变场景，常量用于只读场景与保护对象不变式。
- `<algorithm>` 更新：`std::fill_n(ptr, n, value)` 把前 `n` 个元素置为 `value`；`std::copy_n(vi.ptr, vi.n, ptr)` 深拷贝 `vi` 的数据；在 assign 中对临时缓冲区执行 `copy_n`，随后交换指针以完成安全赋值。

# 任务四

## 矩阵类 Matrix

### 源码
> matrix.hpp

```cpp
#pragma once

// 类Matrix声明
class Matrix {
public:
    Matrix(int rows_, int cols_, double value = 0); // 构造rows_*cols_矩阵对象, 初值value
    Matrix(int rows_, double value = 0);    // 构造rows_*rows_方阵对象, 初值value
    Matrix(const Matrix &x);    // 深复制
    ~Matrix();
    
    void set(const double *pvalue, int size);   // 按行复制pvalue指向的数据，要求size=rows*cols,否则报错退出
    void clear();   // 矩阵对象数据项置0
    
    const double& at(int i, int j) const;   // 返回矩阵对象索引(i,j)对应的数据项const引用（越界则报错后退出）
    double& at(int i, int j);   // 返回矩阵对象索引(i,j)对应的数据项引用（越界则报错后退出）
    
    int rows() const;   // 返回矩阵对象行数
    int cols() const;   // 返回矩阵对象列数
    void print() const;   // 按行打印数据

private:
    int n_rows;      // 矩阵对象内元素行数
    int n_cols;      // 矩阵对象内元素列数
    double *ptr;    // 数据区
};
```

> matrix.cpp

```cpp
#include "matrix.hpp"
#include <iostream>
#include <cstdlib>
#include <algorithm>

Matrix::Matrix(int rows_, int cols_, double value): n_rows{rows_}, n_cols{cols_}, ptr{nullptr} {
    if(n_rows <= 0 || n_cols <= 0) {
        std::cerr << "SizeError: rows and cols must be positive\n";
        std::exit(1);
    }
    ptr = new double[n_rows * n_cols];
    std::fill_n(ptr, n_rows * n_cols, value);
}

Matrix::Matrix(int rows_, double value): Matrix(rows_, rows_, value) {
}

Matrix::Matrix(const Matrix &x): n_rows{x.n_rows}, n_cols{x.n_cols}, ptr{new double[n_rows * n_cols]} {
    std::copy_n(x.ptr, n_rows * n_cols, ptr);
}

Matrix::~Matrix() {
    delete[] ptr;
}

void Matrix::set(const double *pvalue, int size) {
    if(size != n_rows * n_cols) {
        std::cerr << "SizeError: size mismatch\n";
        std::exit(1);
    }
    for(int i = 0; i < n_rows * n_cols; ++i)
        ptr[i] = pvalue[i];
}

void Matrix::clear() {
    std::fill_n(ptr, n_rows * n_cols, 0);
}

const double& Matrix::at(int i, int j) const {
    if(i < 0 || i >= n_rows || j < 0 || j >= n_cols) {
        std::cerr << "IndexError: index out of range\n";
        std::exit(1);
    }
    return ptr[i * n_cols + j];
}

double& Matrix::at(int i, int j) {
    if(i < 0 || i >= n_rows || j < 0 || j >= n_cols) {
        std::cerr << "IndexError: index out of range\n";
        std::exit(1);
    }
    return ptr[i * n_cols + j];
}

int Matrix::rows() const {
    return n_rows;
}

int Matrix::cols() const {
    return n_cols;
}

void Matrix::print() const {
    for(int i = 0; i < n_rows; ++i) {
        std::cout << at(i, 0);
        for(int j = 1; j < n_cols; ++j)
            std::cout << ", " << at(i, j);
        std::cout << '\n';
    }
}
```

> task4.cpp

```cpp
#include <iostream>
#include <cstdlib>
#include "matrix.hpp"

void test1();
void test2();
void output(const Matrix &m, int row_index);

int main() {
    std::cout << "测试1: \n";
    test1();
    std::cout << "\n测试2: \n";
    test2();
}

void test1() {
    double x[1000] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n, m;
    std::cout << "Enter n and m: ";
    std::cin >> n >> m;
    
    Matrix m1(n, m);
    m1.set(x, n*m);
    
    Matrix m2(m, n);
    m2.set(x, m*n);
    
    Matrix m3(n);
    m3.set(x, n*n);
    
    std::cout << "矩阵对象m1: \n";   m1.print();
    std::cout << "矩阵对象m2: \n";   m2.print();
    std::cout << "矩阵对象m3: \n";   m3.print();
}

void test2() {
    Matrix m1(2, 3, -1);
    const Matrix m2(m1);
    
    std::cout << "矩阵对象m1: \n";   m1.print();
    std::cout << "矩阵对象m2: \n";   m2.print();
    
    m1.clear();
    m1.at(0, 0) = 1;
    
    std::cout << "m1更新后: \n";
    std::cout << "矩阵对象m1第0行 "; output(m1, 0);
    std::cout << "矩阵对象m2第0行: "; output(m2, 0);
}

void output(const Matrix &m, int row_index) {
    if(row_index < 0 || row_index > m.rows()) {
        std::cerr << "IndexError: row index out of range\n";
        std::exit(1);
    }
    std::cout << m.at(row_index, 0);
    for(int j = 1; j < m.cols(); ++j)
        std::cout << ", " << m.at(row_index, j);
    std::cout << '\n';
}
```

### 结果

```
测试1:
Enter n and m: 2 3
矩阵对象m1:
1, 2, 3
4, 5, 6
矩阵对象m2:
1, 2
3, 4
5, 6
矩阵对象m3:
1, 2
3, 4

测试2:
矩阵对象m1:
-1, -1, -1
-1, -1, -1
矩阵对象m2:
-1, -1, -1
-1, -1, -1
m1更新后:
矩阵对象m1第0行 1, 0, 0
矩阵对象m2第0行: -1, -1, -1
```

# 任务五

## 通讯录 ContactBook

### 源码
> contact.hpp

```cpp
#pragma once
#include <iostream>
#include <string>

// 联系人类
class Contact {
public:
    Contact(const std::string &name_, const std::string &phone_);
    const std::string &get_name() const;
    const std::string &get_phone() const;
    void display() const;

private:
    std::string name;    // 必填项
    std::string phone;   // 必填项
};

Contact::Contact(const std::string &name_, const std::string &phone_):name{name_}, phone{phone_} {
}

const std::string& Contact::get_name() const {
    return name;
}

const std::string& Contact::get_phone() const {
    return phone;
}

void Contact::display() const {
    std::cout << name << ", " << phone;
}
```

> contactBook.hpp

```cpp
#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include "contact.hpp"

// 通讯录类
class ContactBook {
public:
    void add(const std::string &name, const std::string &phone); // 添加联系人
    void remove(const std::string &name); // 移除联系人
    void find(const std::string &name) const; // 查找联系人
    void display() const; // 显示所有联系人
    size_t size() const;

private:
    int index(const std::string &name) const;  // 返回联系人在contacts内索引，如不存在，返回-1
    void sort(); // 按姓名字典序升序排序通讯录

private:
    std::vector<Contact> contacts;
};

void ContactBook::add(const std::string &name, const std::string &phone) {
    if(index(name) == -1) {
        contacts.push_back(Contact(name, phone));
        std::cout << name << " add successfully.\n";
        sort();
        return;
    }
    std::cout << name << " already exists. fail to add!\n";
}

void ContactBook::remove(const std::string &name) {
    int i = index(name);
    if(i == -1) {
        std::cout << name << " not found, fail to remove!\n";
        return;
    }
    contacts.erase(contacts.begin()+i);
    std::cout << name << " remove successfully.\n";
}

void ContactBook::find(const std::string &name) const {
    int i = index(name);
    if(i == -1) {
        std::cout << name << " not found!\n";
        return;
    }
    contacts[i].display();
    std::cout << '\n';
}

void ContactBook::display() const {
    for(auto &c: contacts) {
        c.display();
        std::cout << '\n';
    }
}

size_t ContactBook::size() const {
    return contacts.size();
}

int ContactBook::index(const std::string &name) const {
    for(int i = 0; i < static_cast<int>(contacts.size()); ++i) {
        if(contacts[i].get_name() == name)
            return i;
    }
    return -1;
}

void ContactBook::sort() {
    std::sort(contacts.begin(), contacts.end(), [](const Contact &a, const Contact &b){
        return a.get_name() < b.get_name();
    });
}
```

> task5.cpp

```cpp
#include "contactBook.hpp"

void test() {
    ContactBook contactbook;
    
    std::cout << "1. add contacts\n";
    contactbook.add("Bob", "18199357253");
    contactbook.add("Alice", "17300886371");
    contactbook.add("Linda", "18184538072");
    contactbook.add("Alice", "17300886371");
    
    std::cout << "\n2. display contacts\n";
    std::cout << "There are " << contactbook.size() << " contacts.\n";
    contactbook.display();
    
    std::cout << "\n3. find contacts\n";
    contactbook.find("Bob");
    contactbook.find("David");
    
    std::cout << "\n4. remove contact\n";
    contactbook.remove("Bob");
    contactbook.remove("David");
}

int main() {
    test();
}
```

### 结果

```
1. add contacts
Bob add successfully.
Alice add successfully.
Linda add successfully.
Alice already exists. fail to add!

2. display contacts
There are 3 contacts.
Alice, 17300886371
Bob, 18199357253
Linda, 18184538072

3. find contacts
Bob, 18199357253
David not found!

4. remove contact
Bob remove successfully.
David not found, fail to remove!
```

# *碎碎念

今天继续练组合与深复制，代码更贴近实际项目，接口最小化与异常安全值得反复推敲。