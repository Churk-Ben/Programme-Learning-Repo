# 实验1 现代C++编程初体验

## 说明

### 阅读文档
请阅读文档，明确各项任务的具体要求、提交方式与截止时间。

### 编程建议
- 随文档准备了部分代码，对测试代码，为避免录入错误，请直接从代码压缩包解压缩后使用。
- 设计性实验，请先独立思考。缺失主动思考和试错过程，会削弱思维训练与编码能力训练。

### 提交规范
- 一次实验的所有任务写在一篇博客中
- 发布博客后，还需要在作业系统中提交链接
- 晚交的实验，按课程规则处理（分数折半）

## 一、实验目的

- 加深对OOP概念（类、对象）和特性（封装）的理解
- 会用C++正确定义、实现、测试类；会创建对象，并基于对象编程
- 加深对C++内存资源管理技术的理解，能够解释构造函数、析构函数的用途，分析它们何时会被调用
- 会用多文件方式组织代码
- 针对具体问题场景，练习运用面向对象思维设计，合理利用C++语言特性（封装与访问权限控制, static, friend, const)，在数据共享和保护之间达到平衡

## 二、实验准备

系统浏览教材第4-5章，熟悉以下内容：

- 类的抽象、设计
- 使用C++定义类、使用类创建对象的语法；构造/析构函数语法、用途及调用时机
- 类的共享与保护机制：访问权限控制、静态成员(static)、友元(friend)、const
- 多文件组织代码

## 三、实验内容

### 1. 实验任务1

验证性实验：简单类T的定义和测试。实践、阅读代码，回答问题。

这个简单任务覆盖以下内容：
- 类的定义（封装）
- 类的使用：对象的创建、访问
- 数据共享
  - 在同一个对象的所有操作之间共享 —— 实现基础：封装
  - 在同一个类的所有对象之间共享 —— 实现机制：类的static成员
  - 在不同模块（类、函数）之间共享 —— 实现机制：友元
- 数据保护机制
  - const对象
  - const引用作为形参
  - const成员数据/const成员函数
- 代码组织方式：多文件结构

#### 代码组织：
- **T.h**: 类T的声明、友元函数声明
- **T.cpp**: 类T的实现、友元函数实现
- **task1.cpp**: 测试模块、main函数

#### T.h
```cpp
#pragma once
#include <string>

// 类T: 声明
class T {
    // 对象属性、方法
public:
    T(int x = 0, int y = 0);    // 普通构造函数
    T(const T &t);              // 复制构造函数
    T(T &&t);                   // 移动构造函数
    ~T();                       // 析构函数
    void adjust(int ratio);     // 按系数成倍调整数据
    void display() const;       // 以(m1, m2)形式显示T类对象信息

private:
    int m1, m2;

    // 类属性、方法
public:
    static int get_cnt();       // 显示当前T类对象总数
    static const std::string doc;   // 类T的描述信息
    static const int max_cnt;       // 类T对象上限

private:
    static int cnt;             // 当前T类对象数目

    // 类T友元函数声明
    friend void func();
};

// 普通函数声明
void func();
```

#### T.cpp
```cpp
#include "T.h"
#include <iostream>
#include <string>

// 类T实现
// static成员数据类外初始化
const std::string T::doc{"a simple class sample"};
const int T::max_cnt = 999;
int T::cnt = 0;

// 类方法
int T::get_cnt() {
    return cnt;
}

// 对象方法
T::T(int x, int y): m1{x}, m2{y} {
    ++cnt;
    std::cout << "T constructor called.\n";
}

T::T(const T &t): m1{t.m1}, m2{t.m2} {
    ++cnt;
    std::cout << "T copy constructor called.\n";
}

T::T(T &&t): m1{t.m1}, m2{t.m2} {
    ++cnt;
    std::cout << "T move constructor called.\n";
}

T::~T() {
    --cnt;
    std::cout << "T destructor called.\n";
}

void T::adjust(int ratio) {
    m1 *= ratio;
    m2 *= ratio;
}

void T::display() const {
    std::cout << "(" << m1 << ", " << m2 << ")" ;
}

// 普通函数实现
void func() {
    T t5(42);
    t5.m2 = 2049;
    std::cout << "t5 = "; t5.display(); std::cout << '\n';
}
```

#### task1.cpp
```cpp
#include "T.h"
#include <iostream>

void test_T();

int main() {
    std::cout << "test Class T: \n";
    test_T();
    std::cout << "\ntest friend func: \n";
    func();
}

void test_T() {
    using std::cout;
    using std::endl;
    
    cout << "T info: " << T::doc << endl;
    cout << "T objects'max count: " << T::max_cnt << endl;
    cout << "T objects'current count: " << T::get_cnt() << endl << endl;
    
    T t1;
    cout << "t1 = "; t1.display(); cout << endl;
    
    T t2(3, 4);
    cout << "t2 = "; t2.display(); cout << endl;
    
    T t3(t2);
    t3.adjust(2);
    cout << "t3 = "; t3.display(); cout << endl;
    
    T t4(std::move(t2));
    cout << "t4 = "; t4.display(); cout << endl;
    
    cout << "test: T objects'current count: " << T::get_cnt() << endl;
}
```

#### 问题回答：

**问题1**：
T.h中，在类T内部，已声明 func 是T的友元函数。在类外部，去掉line36，重新编译，程序能否正常运行。
如果能，回答YES；如果不能，以截图形式提供编译报错信息，说明原因。

**问题2**：
T.h中，line9-12给出了各种构造函数、析构函数。总结它们各自的功能、调用时机。

**问题3**：
T.cpp中，line13-15，剪切到T.h的末尾，重新编译，程序能否正确编译。
如不能，以截图形式给出报错信息，分析原因。

### 2. 实验任务2

不使用C++标准库提供的复数模板类，设计并实现一个简化版复数类Complex。

#### 类属性
- **doc**: 用于类说明， std::string 类型，常量，公有
  - 说明信息为: "a simplified complex class"

#### 对象属性
- 用于表示复数的实部real和虚部imag, 均为小数形式，私有

#### 对象方法
##### 构造函数
要求支持以下方式构造复数对象：
- `Complex c1;`                  // 构造的复数对象，对应数学中的0+0i
- `Complex c2(3.5);`             // 构造的复数对象，对应数学中的3.5+0i
- `Complex c3(3,-4);`            // 构造的复数对象，对应数学中的3-4i
- `Complex c4(c2);`              // 用已经存在的复数对象c2构造c4
- `Complex c5 = c2;`             // 用已经存在的复数对象c2构造c5

##### 其他方法
- `get_real()` 返回复数实部
- `get_imag()` 返回复数虚部
- `add()` 用于把一个复数加到自身，用法： `c1.add(c2)` , 相当于 `c1 += c2`

#### 接口
##### 友元函数
- `output()` 用于输出一个复数，以a+bi的形式，如3 + 4i
- `abs()` 用于对复数取模。比如， `Complex c(3, 4);` 调用 `abs(c)` 结果为5.0
- `add()` 用于实现两个复数相加，返回复数。比如 `c3 = add(c1, c2)`
- `is_equal()` 用于判断两个复数是否相等，相等返回 true , 否则，返回 false
- `is_not_equal()` 用于判断两个复数是否相等，不相等返回 true , 否则，返回 false

#### 代码要求
- 采用多文件组织代码：
  - **Complex.h**: 类Complex声明、友元函数声明
  - **Complex.cpp**: 类Complex实现、友元函数实现
  - **task2.cpp**: 测试代码、main()函数

#### 类设计及编码风格要求
- 设计并实现类时，合理利用数据的共享和保护机制，尽可能在数据共享和保护之间达到平衡
- 关注编码风格、可读性、易维护性

#### task2.cpp源码
```cpp
// 待补足头文件
// xxx
#include <iostream>
#include <iomanip>
#include <complex>

void test_Complex();
void test_std_complex();

int main() {
    std::cout << "*******测试1: 自定义类Complex*******\n";
    test_Complex();
    std::cout << "\n*******测试2: 标准库模板类complex*******\n";
    test_std_complex();
}

void test_Complex() {
    using std::cout;
    using std::endl;
    using std::boolalpha;
    
    cout << "类成员测试: " << endl;
    cout << Complex::doc << endl << endl;
    
    cout << "Complex对象测试: " << endl;
    Complex c1;
    Complex c2(3, -4);
    Complex c3(c2);
    Complex c4 = c2;
    const Complex c5(3.5);
    
    cout << "c1 = "; output(c1); cout << endl;
    cout << "c2 = "; output(c2); cout << endl;
    cout << "c3 = "; output(c3); cout << endl;
    cout << "c4 = "; output(c4); cout << endl;
    cout << "c5.real = " << c5.get_real()
         << ", c5.imag = " << c5.get_imag() << endl << endl;
    
    cout << "复数运算测试: " << endl;
    cout << "abs(c2) = " << abs(c2) << endl;
    c1.add(c2);
    cout << "c1 += c2, c1 = "; output(c1); cout << endl;
    cout << boolalpha;
    cout << "c1 == c2 : " << is_equal(c1, c2) << endl;
    cout << "c1 != c2 : " << is_not_equal(c1, c2) << endl;
    c4 = add(c2, c3);
    cout << "c4 = c2 + c3, c4 = "; output(c4); cout << endl;
}

void test_std_complex() {
    using std::cout;
    using std::endl;
    using std::boolalpha;
    
    cout << "std::complex<double>对象测试: " << endl;
    std::complex<double> c1;
    std::complex<double> c2(3, -4);
    std::complex<double> c3(c2);
    std::complex<double> c4 = c2;
    const std::complex<double> c5(3.5);
    
    cout << "c1 = " << c1 << endl;
    cout << "c2 = " << c2 << endl;
    cout << "c3 = " << c3 << endl;
    cout << "c4 = " << c4 << endl;
    cout << "c5.real = " << c5.real()
         << ", c5.imag = " << c5.imag() << endl << endl;
    
    cout << "复数运算测试: " << endl;
    cout << "abs(c2) = " << abs(c2) << endl;
    c1 += c2;
    cout << "c1 += c2, c1 = " << c1 << endl;
    cout << boolalpha;
    cout << "c1 == c2 : " << (c1 == c2)<< endl;
    cout << "c1 != c2 : " << (c1 != c2) << endl;
    c4 = c2 + c3;
    cout << "c4 = c2 + c3, c4 = " << c4 << endl;
}
```

#### 问题回答：

**问题1**：
比较自定义类 Complex 和标准库模板类 complex 的用法，在使用形式上，哪一种更简洁？函数和运算内在有关联吗？

| 自定义类 Complex | 标准库模板类 complex |
|-----------------|---------------------|
| c1.add(c2)      | c1 += c2            |
| c4 = add(c2, c3)| c4 = c2 + c3        |
| is_equal(c1, c2)| c1 == c2            |
| is_not_equal(c1, c2)| c1 != c2      |
| output(c1)      | cout << c1          |
| abs(c2)         | abs(c2)             |

**问题2-1**：
自定义 Complex 中, output/abs/add/ 等均设为友元，它们真的需要访问私有数据吗？（回答"是/否"并给出理由）

**问题2-2**：
标准库 std::complex 是否把 abs 设为友元？（查阅 cppreference后回答）

**问题2-3**：
什么时候才考虑使用 friend？总结你的思考。

**问题3**：
如果构造对象时禁用=形式，即遇到 Complex c4 = c2; 编译报错，类Complex的设计应如何调整？

### 3. 实验任务3

设计并实现播放器控制类 PlayerControl，模拟音频播放器中控制操作：播放、暂停、下一首、上一首、结束、退出。
（仅模拟播放控制器行为，暂不实现真实音频播放控制）

#### 播放控制，用枚举类型表示，限定以下枚举值：
```cpp
enum class ControlType {Play, Pause, Next, Prev, Stop, Unknown};
```

#### 类属性
- **total_cnt**，int类型，私有，用于记录播放控制操作总次数

#### 类方法
- `int get_cnt()`, 公有，用于获取当前播放控制操作总数

#### 接口
- `ControlType parse(const std::string& control_str);`
  - 负责将用户输入的控制命令串转换成枚举值
  - 解析转换时，忽略大小写。例如，用户输入字符串"play", "Play", "PLAY"，均会被解析成枚举值Play
- `void execute(ControlType cmd) const;`
  - 负责模拟执行控制命令
  - 例如，当cmd是枚举值Play时，屏幕上输出"播放"（暂不实现实际播放行为）

#### 代码组织
多文件方式：
- **PlayerControl.h**: 播放控制类PlayerControl声明
- **PlayerControl.cpp**: 播放控制类PlayerControl实现
- **task3.cpp**: 测试模块 + main

#### PlayerControl.h
```cpp
#pragma once
#include <string>

enum class ControlType {Play, Pause, Next, Prev, Stop, Unknown};

class PlayerControl {
public:
    PlayerControl();
    ControlType parse(const std::string& control_str);   // 实现std::string --> ControlType转换
    void execute(ControlType cmd) const;   // 执行控制操作（以打印输出模拟）
    static int get_cnt();

private:
    static int total_cnt;
};
```

#### PlayerControl.cpp
```cpp
#include "PlayerControl.h"
#include <iostream>
#include <algorithm>

int PlayerControl::total_cnt = 0;

PlayerControl::PlayerControl() {}

// 待补足
// 1. 将输入字符串转为小写，实现大小写不敏感
// 2. 匹配"play"/"pause"/"next"/"prev"/"stop"并返回对应枚举
// 3. 未匹配的字符串返回ControlType::Unknown
// 4. 每次成功调用parse时递增total_cnt
ControlType PlayerControl::parse(const std::string& control_str) {
    // xxx
}

void PlayerControl::execute(ControlType cmd) const {
    switch (cmd) {
        case ControlType::Play:  std::cout << "[play] Playing music...\n"; break;
        case ControlType::Pause: std::cout << "[Pause] Music paused\n";    break;
        case ControlType::Next:  std::cout << "[Next] Skipping to next track\n"; break;
        case ControlType::Prev:  std::cout << "[Prev] Back to previous track\n"; break;
        case ControlType::Stop:  std::cout << "[Stop] Music stopped\n"; break;
        default:                 std::cout << "[Error] unknown control\n"; break;
    }
}

int PlayerControl::get_cnt() {
    return total_cnt;
}
```

#### task3.cpp
```cpp
#include "PlayerControl.h"
#include <iostream>

void test() {
    PlayerControl controller;
    std::string control_str;
    std::cout << "Enter Control: (play/pause/next/prev/stop/quit):\n";
    
    while(std::cin >> control_str) {
        if(control_str == "quit")
            break;
        ControlType cmd = controller.parse(control_str);
        controller.execute(cmd);
        std::cout << "Current Player control: " << PlayerControl::get_cnt() << "\n\n";
    }
}

int main() {
    test();
}
```

#### 思考（选做*）
如果希望输模拟播放控制时，输出控制更现代（使用emoji），如下测试截图所示。如何调整代码实现？

### 4. 实验任务4

设计并实现一个分数类Fraction。要求如下：

#### 类属性
- **doc**: 用于类说明， std::string 类型，常量，公有
  - 说明信息为: "Fraction类 v 0.01版. 目前仅支持分数对象的构造、输出、加/减/乘/除运算."

#### 对象属性
- 用于表示分数的分子up和分母down, 均为整数形式，私有

#### 对象方法
##### 构造函数
要求支持以下方式构造分数对象：
- `Fraction f1(2);`         // 构造的分数对象，对应数学中的分数2/1，分母为1
- `Fraction f2(2, -3);`     // 构造的分数对象，对应数学中的分数-2/3
- `Fraction f3(f2);`        // 用已经存在的分数对象，构造新的分数对象

##### 其他方法
- `get_up()` 返回分子
- `get_down()` 返回分母
- `negative()` 用于求负，支持 `Fraction f2 = f1.negative()`，形如 `f2 = -f1`
  - 求负运算，分数对象f1本身不变，返回值是求负后的分数对象

#### 接口
##### 工具函数
这些工具函数以何种方案实现（友元/命名空间+自由函数/类+static函数），请自行设计。
- `output()` 用于输出一个分数，以形如2/3或-2/3这样的形式
  - （输出化简后的形式，比如-4/10，输出时化简后的-2/5）
- `add()` 用于实现两个分数相加，返回分数。比如 `f3 = add(f1, f2)`
- `sub()` 用于实现两个分数相减，返回分数。比如 `f3 = sub(f1, f2)`
- `mul()` 用于实现两个分数相乘，返回分数。比如 `f3 = mul(f1, f2)`
- `div()` 用于实现两个分数相除法，返回分数。比如 `f3 = div(f1, f2)`

#### 代码组织
要求采用多文件方式：
- **Fraction.h**: 类Fraction声明、其他声明
- **Fraction.cpp**: 类Fraction实现、其他实现
- **task4.cpp**: 测试代码、main()函数

#### task4.cpp
```cpp
#include "Fraction.h"
#include <iostream>

void test1();
void test2();

int main() {
    std::cout << "测试1: Fraction类基础功能测试\n";
    test1();
    std::cout << "\n测试2: 分母为0测试: \n";
    test2();
}

void test1() {
    using std::cout;
    using std::endl;
    
    cout << "Fraction类测试: " << endl;
    cout << Fraction::doc << endl << endl;
    
    Fraction f1(5);
    Fraction f2(3, -4), f3(-18, 12);
    Fraction f4(f3);
    
    cout << "f1 = "; output(f1); cout << endl;
    cout << "f2 = "; output(f2); cout << endl;
    cout << "f3 = "; output(f3); cout << endl;
    cout << "f4 = "; output(f4); cout << endl;
    
    const Fraction f5(f4.negative());
    cout << "f5 = "; output(f5); cout << endl;
    cout << "f5.get_up() = " << f5.get_up()
         << ", f5.get_down() = " << f5.get_down() << endl;
    
    cout << "f1 + f2 = "; output(add(f1, f2)); cout << endl;
    cout << "f1 - f2 = "; output(sub(f1, f2)); cout << endl;
    cout << "f1 * f2 = "; output(mul(f1, f2)); cout << endl;
    cout << "f1 / f2 = "; output(div(f1, f2)); cout << endl;
    cout << "f4 + f5 = "; output(add(f4, f5)); cout << endl;
}

void test2() {
    using std::cout;
    using std::endl;
    
    Fraction f6(42, 55), f7(0, 3);
    cout << "f6 = "; output(f6); cout << endl;
    cout << "f7 = "; output(f7); cout << endl;
    cout << "f6 / f7 = "; output(div(f6, f7)); cout << endl;
}
```

#### 问题回答：
分数的输出和计算， output/add/sub/mul/div ，你选择的是哪一种设计方案？（友元/自由函数/命名空间+自由函数/类+static)

你的决策理由？如友元方案的优缺点、静态成员函数方案的适用场景、命名空间方案的考虑因素等。

## 四、实验结论

### 1. 实验任务1
此部分书写内容：
- 分别给出T.h, T.cpp, task1.cpp源码，以及，运行测试结果截图
- 回答问题

### 2. 实验任务2
此部分书写内容：
- 分别给出Complex.h, Complex.cpp源码，以及，运行测试结果截图
- 回答问题

### 3. 实验任务3
此部分书写内容：
- 分别给出PlayerControl.h, PlayerControl.cpp源码，以及，运行测试结果截图

### 4. 实验任务4
此部分书写内容：
- 分别给出Fraction.h, Fraction.cpp源码，以及，运行测试结果截图
- 回答问题

## 五、实验总结（选）

## 六、实验文档提交要求

## 七、博客园编辑器使用补充说明