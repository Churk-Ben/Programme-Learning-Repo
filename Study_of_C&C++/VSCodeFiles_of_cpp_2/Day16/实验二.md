# 任务一

## 验证性实验

### 源码
>
> T.h

```cpp
#pragma once

#include <string>

// 类T: 声明
class T {
// 对象属性、方法
public:
    T(int x = 0, int y = 0);   // 普通构造函数
    T(const T &t);  // 复制构造函数
    T(T &&t);       // 移动构造函数
    ~T();           // 析构函数

    void adjust(int ratio);      // 按系数成倍调整数据
    void display() const;           // 以(m1, m2)形式显示T类对象信息

private:
    int m1, m2;

// 类属性、方法
public:
    static int get_cnt();          // 显示当前T类对象总数

public:
    static const std::string doc;       // 类T的描述信息
    static const int max_cnt;           // 类T对象上限

private:
    static int cnt;         // 当前T类对象数目

// 类T友元函数声明
    friend void func();
};

// 普通函数声明
void func();

```

> T.cpp

```cpp
#include "T.h"
#include <iostream>
#include <string>

// 类T实现

// static成员数据类外初始化
const std::string T::doc{"a simple class sample"};
const int T::max_cnt = 999;
int T::cnt = 0;

// 类方法
int T::get_cnt() {
   return cnt;
}

// 对象方法
T::T(int x, int y): m1{x}, m2{y} { 
    ++cnt; 
    std::cout << "T constructor called.\n";
} 

T::T(const T &t): m1{t.m1}, m2{t.m2} {
    ++cnt;
    std::cout << "T copy constructor called.\n";
}

T::T(T &&t): m1{t.m1}, m2{t.m2} {
    ++cnt;
    std::cout << "T move constructor called.\n";
}    

T::~T() {
    --cnt;
    std::cout << "T destructor called.\n";
}           

void T::adjust(int ratio) {
    m1 *= ratio;
    m2 *= ratio;
}    

void T::display() const {
    std::cout << "(" << m1 << ", " << m2 << ")" ;
}     

// 普通函数实现
void func() {
    T t5(42);
    t5.m2 = 2049;
    std::cout << "t5 = "; t5.display(); std::cout << '\n';
}
```

> task1.cpp

```cpp
#include "T.h"
#include <iostream>

void test_T();

int main() {
    std::cout << "test Class T: \n";
    test_T();

    std::cout << "\ntest friend func: \n";
    func();
}

void test_T() {
    using std::cout;
    using std::endl;

    cout << "T info: " << T::doc << endl;
    cout << "T objects'max count: " << T::max_cnt << endl;
    cout << "T objects'current count: " << T::get_cnt() << endl << endl;

    T t1;
    cout << "t1 = "; t1.display(); cout << endl;

    T t2(3, 4);
    cout << "t2 = "; t2.display(); cout << endl;

    T t3(t2);
    t3.adjust(2);
    cout << "t3 = "; t3.display(); cout << endl;

    T t4(std::move(t2));
    cout << "t4 = "; t4.display(); cout << endl;

    cout << "test: T objects'current count: " << T::get_cnt() << endl;
}
```

### 结果

![image](https://img2024.cnblogs.com/blog/3074083/202510/3074083-20251021230009079-1112494875.png)

### 回答

- 可见报错为在作用域内未声明`func`函数, 因为 `func()` 是类外定义的友元函数，必须先声明.
  ![image](https://img2024.cnblogs.com/blog/3074083/202510/3074083-20251021230305399-1471658937.png)
  
- 构造函数用于对象初始化，复制构造用于拷贝已有对象，移动构造用于资源转移，析构函数用于资源释放。
- 静态成员变量必须在类外初始化，否则链接失败。
- ![image](https://img2024.cnblogs.com/blog/3074083/202510/3074083-20251021231227342-2041754556.png)

# 任务二

## Complex

### 源码
>
> Complex.h

```cpp
#pragma once
#include <string>

class Complex
{
public:
    static const std::string doc;

    Complex();
    Complex(double r);
    Complex(double r, double i);
    Complex(const Complex &c);

    double get_real() const;
    double get_imag() const;
    void add(const Complex &c);

    friend void output(const Complex &c);
    friend double abs(const Complex &c);
    friend Complex add(const Complex &a, const Complex &b);
    friend bool is_equal(const Complex &a, const Complex &b);
    friend bool is_not_equal(const Complex &a, const Complex &b);

private:
    double real, imag;
};

```

> Complex.cpp

```cpp
#include "Complex.h"
#include <iostream>
#include <cmath>

const std::string Complex::doc{"a simplified Complex class"};

Complex::Complex() : real{0}, imag{0} {}
Complex::Complex(double r) : real{r}, imag{0} {}
Complex::Complex(double r, double i) : real{r}, imag{i} {}
Complex::Complex(const Complex &c) : real{c.real}, imag{c.imag} {}

double Complex::get_real() const { return real; }
double Complex::get_imag() const { return imag; }

void Complex::add(const Complex &c)
{
    real += c.real;
    imag += c.imag;
}

void output(const Complex &c)
{
    std::cout << c.real << (c.imag >= 0 ? " + " : " - ") << std::abs(c.imag) << "i";
}

double abs(const Complex &c)
{
    return std::sqrt(c.real * c.real + c.imag * c.imag);
}

Complex add(const Complex &a, const Complex &b)
{
    return Complex(a.real + b.real, a.imag + b.imag);
}

bool is_equal(const Complex &a, const Complex &b)
{
    return a.real == b.real && a.imag == b.imag;
}

bool is_not_equal(const Complex &a, const Complex &b)
{
    return !is_equal(a, b);
}

```

> task2.cpp

```cpp
// 待补足头文件
// xxx
#include <iostream>
#include <iomanip>
#include <complex>
#include "Complex.h"

void test_Complex();
void test_std_complex();

int main()
{
    std::cout << "*******测试1: 自定义类Complex*******\n";
    test_Complex();

    std::cout << "\n*******测试2: 标准库模板类complex*******\n";
    test_std_complex();
}

void test_Complex()
{
    using std::boolalpha;
    using std::cout;
    using std::endl;

    cout << "类成员测试: " << endl;
    cout << Complex::doc << endl
         << endl;

    cout << "Complex对象测试: " << endl;
    Complex c1;
    Complex c2(3, -4);
    Complex c3(c2);
    Complex c4 = c2;
    const Complex c5(3.5);

    cout << "c1 = ";
    output(c1);
    cout << endl;
    cout << "c2 = ";
    output(c2);
    cout << endl;
    cout << "c3 = ";
    output(c3);
    cout << endl;
    cout << "c4 = ";
    output(c4);
    cout << endl;
    cout << "c5.real = " << c5.get_real()
         << ", c5.imag = " << c5.get_imag() << endl
         << endl;

    cout << "复数运算测试: " << endl;
    cout << "abs(c2) = " << abs(c2) << endl;
    c1.add(c2);
    cout << "c1 += c2, c1 = ";
    output(c1);
    cout << endl;
    cout << boolalpha;
    cout << "c1 == c2 : " << is_equal(c1, c2) << endl;
    cout << "c1 != c2 : " << is_not_equal(c1, c2) << endl;
    c4 = add(c2, c3);
    cout << "c4 = c2 + c3, c4 = ";
    output(c4);
    cout << endl;
}

void test_std_complex()
{
    using std::boolalpha;
    using std::cout;
    using std::endl;

    cout << "std::complex<double>对象测试: " << endl;
    std::complex<double> c1;
    std::complex<double> c2(3, -4);
    std::complex<double> c3(c2);
    std::complex<double> c4 = c2;
    const std::complex<double> c5(3.5);

    cout << "c1 = " << c1 << endl;
    cout << "c2 = " << c2 << endl;
    cout << "c3 = " << c3 << endl;
    cout << "c4 = " << c4 << endl;

    cout << "c5.real = " << c5.real()
         << ", c5.imag = " << c5.imag() << endl
         << endl;

    cout << "复数运算测试: " << endl;
    cout << "abs(c2) = " << abs(c2) << endl;
    c1 += c2;
    cout << "c1 += c2, c1 = " << c1 << endl;
    cout << boolalpha;
    cout << "c1 == c2 : " << (c1 == c2) << endl;
    cout << "c1 != c2 : " << (c1 != c2) << endl;
    c4 = c2 + c3;
    cout << "c4 = c2 + c3, c4 = " << c4 << endl;
}
```

### 结果

![image](https://img2024.cnblogs.com/blog/3074083/202510/3074083-20251021232134228-775990780.png)

### 回答

- 标准库更简洁，重载运算符用起来巴适得很.
- - 是，需要访问私有成员
- - 并非友元函数 见[cpp文档](http://www.man6.org/docs/cppreference-doc/reference/en.cppreference.com/w/cpp/header/complex.html)
- - 当需要访问私有成员但不希望暴露接口时使用 `friend`。

# 任务三

## 播放器

### 源码
>
> PlayerControl.h

```cpp
#pragma once
#include <string>

enum class ControlType
{
    Play,
    Pause,
    Next,
    Prev,
    Stop,
    Unknown
};

class PlayerControl
{
public:
    PlayerControl();

    ControlType parse(const std::string &control_str); // 实现std::string --> ControlType转换
    void execute(ControlType cmd) const;               // 执行控制操作（以打印输出模拟）

    static int get_cnt();

private:
    static int total_cnt;
};
```

> PlayerControl.cpp

```cpp
#include "PlayerControl.h"
#include <iostream>
#include <algorithm>

int PlayerControl::total_cnt = 0;

PlayerControl::PlayerControl() {}

// 待补足
// 1. 将输入字符串转为小写，实现大小写不敏感
// 2. 匹配"play"/"pause"/"next"/"prev"/"stop"并返回对应枚举
// 3. 未匹配的字符串返回ControlType::Unknown
// 4. 每次成功调用parse时递增total_cnt
ControlType PlayerControl::parse(const std::string &control_str)
{
    std::string cmd = control_str;
    std::transform(cmd.begin(), cmd.end(), cmd.begin(), ::tolower);
    ++total_cnt;

    if (cmd == "play")
        return ControlType::Play;
    if (cmd == "pause")
        return ControlType::Pause;
    if (cmd == "next")
        return ControlType::Next;
    if (cmd == "prev")
        return ControlType::Prev;
    if (cmd == "stop")
        return ControlType::Stop;
    return ControlType::Unknown;
}

void PlayerControl::execute(ControlType cmd) const
{
    switch (cmd)
    {
    case ControlType::Play:
        std::cout << "[play] Playing music...\n";
        break;
    case ControlType::Pause:
        std::cout << "[Pause] Music paused\n";
        break;
    case ControlType::Next:
        std::cout << "[Next] Skipping to next track\n";
        break;
    case ControlType::Prev:
        std::cout << "[Prev] Back to previous track\n";
        break;
    case ControlType::Stop:
        std::cout << "[Stop] Music stopped\n";
        break;
    default:
        std::cout << "[Error] unknown control\n";
        break;
    }
}

int PlayerControl::get_cnt()
{
    return total_cnt;
}
```

> task3.cpp

```cpp
#include "PlayerControl.h"
#include <iostream>

void test()
{
    PlayerControl controller;
    std::string control_str;
    std::cout << "Enter Control: (play/pause/next/prev/stop/quit):\n";

    while (std::cin >> control_str)
    {
        if (control_str == "quit")
            break;

        ControlType cmd = controller.parse(control_str);
        controller.execute(cmd);
        std::cout << "Current Player control: " << PlayerControl::get_cnt() << "\n\n";
    }
}

int main()
{
    test();
}
```

### 结果

![image](https://img2024.cnblogs.com/blog/3074083/202510/3074083-20251021234655331-351937803.png)

# 任务四

## Fraction

### 源码
>
> Fraction.h

```cpp
#pragma once
#include <string>

class Fraction
{
public:
    static const std::string doc;

    Fraction(int up);
    Fraction(int up, int down);
    Fraction(const Fraction &f);

    int get_up() const;
    int get_down() const;
    Fraction negative() const;

private:
    int up, down;
    void simplify();

    friend void output(const Fraction &f);
    friend Fraction add(const Fraction &a, const Fraction &b);
    friend Fraction sub(const Fraction &a, const Fraction &b);
    friend Fraction mul(const Fraction &a, const Fraction &b);
    friend Fraction div(const Fraction &a, const Fraction &b);
};

```

> Fraction.cpp

```cpp
#include "Fraction.h"
#include <iostream>
#include <numeric>

const std::string Fraction::doc{"a simplified fraction class"};

Fraction::Fraction(int u) : up{u}, down{1} {}
Fraction::Fraction(int u, int d) : up{u}, down{d}
{
    if (down < 0)
    {
        up = -up;
        down = -down;
    }
    simplify();
}
Fraction::Fraction(const Fraction &f) : up{f.up}, down{f.down} {}

int Fraction::get_up() const { return up; }
int Fraction::get_down() const { return down; }

Fraction Fraction::negative() const
{
    return Fraction(-up, down);
}

void Fraction::simplify()
{
    int g = std::gcd(up, down);
    if (g != 0)
    {
        up /= g;
        down /= g;
    }
}

void output(const Fraction &f)
{
    if (f.down == 0)
    {
        std::cout << "分母不能为0";
    }
    else if (f.down == 1)
    {
        std::cout << f.up;
    }
    else
    {
        std::cout << f.up << "/" << f.down;
    }
}

Fraction add(const Fraction &a, const Fraction &b)
{
    return Fraction(a.up * b.down + b.up * a.down, a.down * b.down);
}

Fraction sub(const Fraction &a, const Fraction &b)
{
    return Fraction(a.up * b.down - b.up * a.down, a.down * b.down);
}

Fraction mul(const Fraction &a, const Fraction &b)
{
    return Fraction(a.up * b.up, a.down * b.down);
}

Fraction div(const Fraction &a, const Fraction &b)
{
    if (b.up == 0)
        return Fraction(1, 0); // 分母为0
    return Fraction(a.up * b.down, a.down * b.up);
}

```

> task4.cpp

```cpp
#include "Fraction.h"
#include <iostream>

void test1();
void test2();

int main() {
    std::cout << "测试1: Fraction类基础功能测试\n";
    test1();

    std::cout << "\n测试2: 分母为0测试: \n";
    test2();
}

void test1() {
    using std::cout;
    using std::endl;   

    cout << "Fraction类测试: " << endl;
    cout << Fraction::doc << endl << endl;

    Fraction f1(5);
    Fraction f2(3, -4), f3(-18, 12);
    Fraction f4(f3);
    cout << "f1 = "; output(f1); cout << endl;
    cout << "f2 = "; output(f2); cout << endl;
    cout << "f3 = "; output(f3); cout << endl;
    cout << "f4 = "; output(f4); cout << endl;

    const Fraction f5(f4.negative());
    cout << "f5 = "; output(f5); cout << endl;
    cout << "f5.get_up() = " << f5.get_up() 
        << ", f5.get_down() = " << f5.get_down() << endl;

    cout << "f1 + f2 = "; output(add(f1, f2)); cout << endl;
    cout << "f1 - f2 = "; output(sub(f1, f2)); cout << endl;
    cout << "f1 * f2 = "; output(mul(f1, f2)); cout << endl;
    cout << "f1 / f2 = "; output(div(f1, f2)); cout << endl;
    cout << "f4 + f5 = "; output(add(f4, f5)); cout << endl;
}

void test2() {
    using std::cout;
    using std::endl;

    Fraction f6(42, 55), f7(0, 3);
    cout << "f6 = "; output(f6); cout << endl;
    cout << "f7 = "; output(f7); cout << endl;
    cout << "f6 / f7 = "; output(div(f6, f7)); cout << endl;
}
```

### 结果

![image](https://img2024.cnblogs.com/blog/3074083/202510/3074083-20251022003931112-678085885.png)

### 回答

- 友元. 接口简介, 方便好写, 适合小模版. 就是高耦合, 大项目维护起来可能有些麻烦.

# *碎碎念

今天没有碎碎念, 今天是怀念 Python Class 优雅简洁的一天
